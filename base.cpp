#include <getopt.h>
#include <cstdlib>
#include "base_helper.h"
#include <iomanip>
#include <algorithm>

using namespace std;

int main(int argc, char **argv){

  
  cout << setprecision(2);
  cout << fixed;
  //VARIABLE DECLARATION
  bool mode_inputed = false;
  string mode_type;
  int lx = 0, ly = 0, rx = 0, ry = 0, num_points = 0; 
  vector< pair<int, int> > coordinate_list;
  vector<int> route_opt;
  double fast_distance = 0;
  
  //GETOPT
  struct option longOpts[] = {
    {"mode", required_argument, NULL, 'm'},
    {"help", no_argument, NULL, 'h'}
  };
  int opt = 0, index = 0;
  while((opt = getopt_long(argc, argv, "m:h", longOpts, &index)) != -1){
    
    switch(opt){
    case 'h':
      
      break;
    case 'm':
      mode_type = optarg;
      mode_inputed = true;
      break;
    case '?':
      cout << "Unrecognized command line arguments" << endl;
      exit(1);
      break;
    }
  }

  if(!mode_inputed){
    cout << "Must specify a mode" << endl;
    exit(1);
  }
  //Use the estimate generated by FASTTSP to be the intial upper bound of OPTTSP
  if(mode_type == "FASTTSP" || mode_type == "OPTTSP"){
    cin >> lx >> ly >> rx >> ry;
    cin >> num_points;
    coordinate_list.resize(num_points);
    int min_distance = -1;
    double total = 0;
    int next_vertex = 0, current_vertex = 0;
    vector<int> path;
    vector<bool> visited(num_points, false);
    //Read in all the vertices in the graph.
    for(int i = 0; i < num_points; ++i){
      int current_x = 0, current_y = 0;
      cin >> current_x >> current_y;
      coordinate_list[i] = pair<int, int> (current_x, current_y);
    }
    //while there are still nodes left to add to the graph.
    while(1){
      visited[current_vertex] = true;
      path.push_back(current_vertex);
     
      //calculate the next closest vertice and add it to the graph.
      for(int i = 0; i < num_points; ++i){
	if(current_vertex != i && !visited[i]){
	 
	  double distance = sqrt(pow(coordinate_list[current_vertex].first - coordinate_list[i].first, 2) +
				 pow(coordinate_list[current_vertex].second - coordinate_list[i].second, 2));
	  if(distance < min_distance || min_distance == -1){
	    min_distance = distance;
	    next_vertex = i;
	  }
	}
      }
      
      if(min_distance == -1){
	break;
      }
      else{
	total = total + min_distance;
	min_distance = -1;
      }
      current_vertex = next_vertex;

    }
   
    //Add the distance to get from the last point to the beginning.
    total = total + sqrt(pow(coordinate_list[path.back()].first - coordinate_list[0].first, 2) +
			 pow(coordinate_list[path.back()].second - coordinate_list[0].second, 2));
    vector <int> new_route (path.size());
    route_opt = path;
    fast_distance = total;
    //Print the output if FASTTSP
    if(mode_type == "FASTTSP"){
      
      cout << total << "\n";
      cout << path[0];
      for(unsigned int i = 1; i < path.size(); ++i){
	cout << " " << path[i];
      }
      cout << "\n";
    }
      
  }
   
  if(mode_type == "MST"){
    //read in variables
    cin >> lx >> ly >> rx >> ry;
    cin >> num_points;
    coordinate_list.resize(num_points);
    vector < vector<bool> > adjacency_matrix (3);
    bool inside = false, border = false, outside = false; 
    //Split the adjacency matrix into those adjacent to 
    //the inside points, outside points, and the border.
    for(unsigned int i = 0; i < adjacency_matrix.size(); ++i){
      adjacency_matrix[i].resize(num_points);
    }
    //add points and check where they are on the border
    //adding them to the correct adjacency matrix.
    for(int i = 0; i < num_points; ++i){
      int current_x, current_y;
      cin >> current_x >> current_y;
      coordinate_list[i] = pair<int, int> (current_x, current_y);
      int check = check_border(coordinate_list[i], lx, ly, rx, ry);
      if(check == 0){
	adjacency_matrix[0][i] = true;
	adjacency_matrix[1][i] = true;
	adjacency_matrix[2][i] = true;
	border = true;
      }
      else if(check == 1){
	adjacency_matrix[0][i] = true;
	adjacency_matrix[1][i] = true;
	adjacency_matrix[2][i] = false;
	inside = true;
      }
      else{
	adjacency_matrix[0][i] = true;
	adjacency_matrix[1][i] = false;
	adjacency_matrix[2][i] = true;
	outside = true;
      }
    }
    //Make sure that a MST can be constructed
    if(border != true){
      if(outside && inside){
	cerr << "Invalid graph\n";
	exit(1);
      }
    }
 
    vector<bool> visited (num_points, false);
    vector<double> min_distance (num_points, -1);
    vector<int> precedent (num_points, -1);
    int current_vertex = 0, min_check = 0;
    min_distance[0] = 0;
    int vertex_type = check_border(coordinate_list[0], lx, ly, rx, ry);

    //While there are still unadded vertices.
    while(min_check != -1){
      //the current vertex is added to the matrix.
      visited[current_vertex] = true;
      min_check = -1;
      for(int i = 0; i < num_points; ++i){
	if(i != current_vertex){
	  
	  //Update all adjacent vertices if closer and unvisited.
	  if(!visited[i] && adjacency_matrix[vertex_type][i]){
	    double distance = sqrt(pow(coordinate_list[current_vertex].first -
				       coordinate_list[i].first, 2) +
				   pow(coordinate_list[current_vertex].second - 
				       coordinate_list[i].second, 2));
	    if(min_distance[i] == -1 || min_distance[i] > distance){
	      min_distance[i] = distance;
	      precedent[i] = current_vertex;
	    }
	  }
	}
      }
      //Look for the next closest vertice.
      for(unsigned int i = 0; i < visited.size(); ++i){
	if(visited[i] == false){
	  if((min_check == -1 && min_distance[i] != -1) || 
	     (min_distance[min_check] > min_distance[i] && min_distance[i] != -1)){
	    min_check = i;
	  }
	}
      }
      
      if(min_check != -1){
	current_vertex = min_check;
      }
      //Check which type of vertice the next closest vertice so the correct adjacency
      //matrix can be looked at.
      vertex_type = check_border(coordinate_list[current_vertex], lx, ly, rx, ry);
    }	  

    //Print out the route and the total.
    double total = 0;
    for(unsigned int i = 0; i < min_distance.size(); ++i){
      total = total + min_distance[i];
    }
    cout << total << "\n";

    for(unsigned int i = 1; i < precedent.size(); ++i){
      int first = precedent[i], second = i;
      if(first > second){
	cout << second << " " << first << "\n";
      }
      else{
	cout << first << " " << second << "\n";
      }
    }
      
  }
  
  if(mode_type == "OPTTSP"){
    vector < vector<double> > best_distances(num_points);
    for(int i = 0; i < num_points; ++i){
      best_distances[i] = vector<double> (num_points, -1);
    }
    //find the average of the two lowest differences out of each point
    for(unsigned int i = 0; i < route_opt.size(); ++i){
      for(unsigned int j = 0; j < route_opt.size(); ++j){
	if(i != j){
	  double distance = sqrt(pow(coordinate_list[i].first -
				     coordinate_list[j].first, 2) +
				 pow(coordinate_list[i].second -
				     coordinate_list[j].second, 2));
	  best_distances[i][j] = distance;
	}
      }
    }
    //The path so far must start at 0.
    vector<int> path_so_far;
    path_so_far.push_back(0);
    queue<int> unvisited;
    for(unsigned int i = 1; i < route_opt.size(); ++i){
      unvisited.push(route_opt[i]);
    }
    //Find the best route, passing in the FASTTSP output as the best upper bound.
    gen_permutations(path_so_far, unvisited, route_opt, best_distances, fast_distance, coordinate_list);
    cout << fast_distance << "\n";
    cout << route_opt[0];
    for(unsigned int i = 1; i < route_opt.size(); ++i){
     cout << " " << route_opt[i];
    }
    cout <<"\n";

    

  }
  return 0;

}
